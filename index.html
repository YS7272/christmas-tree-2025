<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Christmas - AI Edition</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Times+New+Roman&display=swap" rel="stylesheet">

    <style>
        :root {
            --c-bg: #000000;
            --c-gold: #d4af37;
            --c-gold-light: #fceea7;
            --font-display: 'Cinzel', serif;
        }

        body {
            margin: 0;
            background-color: var(--c-bg);
            overflow: hidden;
            font-family: var(--font-display);
            color: var(--c-gold);
            user-select: none;
        }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            transition: opacity 0.8s ease;
        }

        .ui-hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Header */
        header {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
        }

        h1 {
            font-size: clamp(32px, 5vw, 64px);
            margin: 0;
            background: linear-gradient(180deg, #fff, var(--c-gold));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(212, 175, 55, 0.6);
            letter-spacing: 6px;
            text-transform: uppercase;
        }

        .subtitle {
            font-size: 14px;
            color: var(--c-gold-light);
            opacity: 0.7;
            letter-spacing: 3px;
            margin-top: 10px;
        }

        /* Controls */
        .controls-wrapper {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            pointer-events: auto;
            flex-direction: column;
            align-items: center;
        }

        .glass-btn {
            position: relative;
            padding: 12px 36px;
            font-family: var(--font-display);
            font-weight: 700;
            color: #fff;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(212, 175, 55, 0.5);
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            text-transform: uppercase;
            letter-spacing: 2px;
            overflow: hidden;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .glass-btn:hover {
            background: rgba(212, 175, 55, 0.15);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.4);
            border-color: var(--c-gold);
            transform: translateY(-2px);
        }

        .glass-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }

        .glass-btn:hover::after {
            left: 100%;
        }

        input[type="file"] { display: none; }

        .hint {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 1px;
        }

        /* Music Toggle */
        #music-toggle {
            position: absolute;
            top: 40px;
            right: 40px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            padding: 0;
            pointer-events: auto;
            font-size: 20px;
            display: flex; align-items: center; justify-content: center;
        }

        /* --- Loader / Start Screen --- */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease, visibility 1s;
        }

        .loader-ring {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(212, 175, 55, 0.1);
            border-top: 2px solid var(--c-gold);
            border-radius: 50%;
            animation: spin 1.5s cubic-bezier(0.68, -0.55, 0.27, 1.55) infinite;
            margin-bottom: 30px;
        }

        #start-btn {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* --- Webcam Monitor (Hidden Logic) --- */
        #cv-debug {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 120px;
            opacity: 0; /* Set to 1 to debug */
            pointer-events: none;
            z-index: 100;
            mix-blend-mode: screen;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <!-- 
        AUDIO FIX: 
        Updated to a reliable Wikimedia Commons CDN Source (High Quality MP3).
        Kevin MacLeod - We Wish You a Merry Christmas.
    -->
    <audio id="bgm" loop preload="auto" crossorigin="anonymous">
        <source src="https://upload.wikimedia.org/wikipedia/commons/transcoded/9/9b/Kevin_MacLeod_-_We_Wish_You_a_Merry_Christmas.ogg/Kevin_MacLeod_-_We_Wish_You_a_Merry_Christmas.ogg.mp3" type="audio/mpeg">
    </audio>

    <!-- Start / Loader Screen -->
    <div id="start-screen">
        <div class="loader-ring"></div>
        <div id="loading-text" style="color:var(--c-gold); letter-spacing: 3px; font-size: 12px;">LOADING MAGIC...</div>
        <button id="start-btn" class="glass-btn">
            ENTER THE MAGIC
        </button>
    </div>

    <!-- Main UI -->
    <div id="ui-layer">
        <header>
            <h1>Merry Christmas</h1>
            <div class="subtitle">AI POWERED INTERACTIVE GREETING</div>
        </header>

        <button id="music-toggle" class="glass-btn">â™«</button>

        <div class="controls-wrapper">
            <label class="glass-btn">
                <span>+ ADD MEMORIES</span>
                <input type="file" id="imageInput" accept="image/*">
            </label>
            <div class="hint">PRESS 'H' TO HIDE UI | GESTURES: PINCH, FIST, OPEN</div>
        </div>
    </div>

    <!-- CV Container -->
    <div id="cv-debug">
        <video id="webcam" style="width:100%;" autoplay playsinline muted></video>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- CONFIGURATION ---
        const CONFIG = {
            colors: {
                gold: 0xd4af37,
                cream: 0xfceea7,
                red: 0x8a0b0b,
                green: 0x0b3815
            },
            particleCount: 1800,
            dustCount: 3000
        };

        // --- STATE MANAGEMENT ---
        const STATE = {
            mode: 'TREE', // TREE, SCATTER, FOCUS
            targetPhoto: null,
            handRotation: { x: 0, y: 0 },
            isPlaying: false,
            musicOn: true
        };

        // --- AUDIO SYSTEM ---
        const audio = document.getElementById('bgm');
        audio.volume = 0.6; // Moderate volume

        document.getElementById('music-toggle').addEventListener('click', () => {
            if(audio.paused) {
                audio.play();
                document.getElementById('music-toggle').style.opacity = '1';
                document.getElementById('music-toggle').innerText = "â™«";
            } else {
                audio.pause();
                document.getElementById('music-toggle').style.opacity = '0.5';
                document.getElementById('music-toggle').innerText = "ðŸ”‡";
            }
        });

        // --- ASSET GENERATION ---
        
        // 1. Procedural Candy Cane Texture
        function createCandyTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#fff'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#cc0000';
            
            for(let i=-128; i<256; i+=32) {
                ctx.beginPath();
                ctx.moveTo(i, 0); ctx.lineTo(i+16, 0);
                ctx.lineTo(i+16-64, 128); ctx.lineTo(i-64, 128);
                ctx.fill();
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            tex.anisotropy = 16;
            return tex;
        }

        // 2. Default Photo Texture
        function createDefaultPhoto() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 640;
            const ctx = canvas.getContext('2d');
            
            // Polarid style
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0,0,512,640);
            ctx.fillStyle = '#111';
            ctx.fillRect(40, 40, 432, 432);
            
            // Text
            ctx.fillStyle = '#d4af37';
            ctx.font = '700 40px Cinzel';
            ctx.textAlign = 'center';
            ctx.fillText("JOYEUX NOÃ‹L", 256, 560);
            
            // Gold Border
            ctx.strokeStyle = '#d4af37';
            ctx.lineWidth = 10;
            ctx.strokeRect(5,5,502,630);

            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        // --- PARTICLE CLASS ---
        class Particle {
            constructor(mesh, index, total) {
                this.mesh = mesh;
                this.index = index;
                this.total = total;
                this.baseScale = mesh.scale.x;
                
                this.velocity = new THREE.Vector3(
                    (Math.random()-0.5)*0.02,
                    (Math.random()-0.5)*0.02,
                    (Math.random()-0.5)*0.02
                );
                
                this.targetPos = new THREE.Vector3();
                this.targetRot = new THREE.Euler();
                this.targetScale = new THREE.Vector3(1,1,1);
                
                // Random phase for breathing animation
                this.phase = Math.random() * Math.PI * 2;
                
                // Initial placement
                this.mesh.position.set((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
            }

            update(mode, time) {
                // Logic per mode
                if (mode === 'TREE') {
                    this.calculateTree(time);
                } else if (mode === 'SCATTER') {
                    this.calculateScatter(time);
                } else if (mode === 'FOCUS') {
                    this.calculateFocus(time);
                }

                // Physics: Smooth dampening
                this.mesh.position.lerp(this.targetPos, 0.04);
                
                const currentQ = new THREE.Quaternion().setFromEuler(this.mesh.rotation);
                const targetQ = new THREE.Quaternion().setFromEuler(this.targetRot);
                this.mesh.rotation.setFromQuaternion(currentQ.slerp(targetQ, 0.05));
                
                this.mesh.scale.lerp(this.targetScale, 0.05);
            }

            calculateTree(time) {
                const h = 45;
                const iNorm = this.index / this.total;
                const y = -20 + iNorm * h;
                
                // Cone shape
                const radius = 18 * (1 - iNorm); 
                const angle = this.index * 0.8 + time * 0.1; // Slowly rotate the whole tree structure logic

                // Add "Breathing" movement
                const bob = Math.sin(time * 2 + this.phase) * 0.5;

                this.targetPos.set(
                    Math.cos(angle) * radius,
                    y + bob, 
                    Math.sin(angle) * radius
                );

                // Face outward
                this.targetRot.set(0, -angle, 0);
                this.targetScale.setScalar(this.baseScale);
            }

            calculateScatter(time) {
                if(!this.scatterOrigin) {
                    const r = 15 + Math.random() * 25;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    this.scatterOrigin = new THREE.Vector3(
                        r * Math.sin(phi) * Math.cos(theta),
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi)
                    );
                }
                
                // Orbiting effect
                const orbitSpeed = 0.2;
                const x = this.scatterOrigin.x * Math.cos(time * orbitSpeed) - this.scatterOrigin.z * Math.sin(time * orbitSpeed);
                const z = this.scatterOrigin.x * Math.sin(time * orbitSpeed) + this.scatterOrigin.z * Math.cos(time * orbitSpeed);
                
                this.targetPos.set(x, this.scatterOrigin.y + Math.sin(time + this.index)*2, z);
                
                // Free rotation
                this.targetRot.x += 0.01;
                this.targetRot.y += 0.01;
                this.targetScale.setScalar(this.baseScale);
            }

            calculateFocus() {
                if (this.mesh.userData.isPhoto && this.mesh === STATE.targetPhoto) {
                    // Center stage
                    this.targetPos.set(0, 2, 32); 
                    this.targetRot.set(0, 0, Math.sin(performance.now()*0.001)*0.05); // Slight sway
                    this.targetScale.setScalar(5.5);
                } else {
                    // Push away to form a tunnel background
                    this.calculateTree(0); // Base tree position
                    this.targetPos.multiplyScalar(2.5); // Explode outwards
                    this.targetPos.z -= 20;
                    this.targetScale.setScalar(0.1); // Shrink
                }
            }
        }

        // --- MAIN SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015); // Add depth fog

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 0, 60);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING & ENVIRONMENT ---
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

        const ambient = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambient);

        // Magical Core Light
        const coreLight = new THREE.PointLight(CONFIG.colors.gold, 2, 60);
        coreLight.position.set(0, 0, 0);
        scene.add(coreLight);

        // Spotlights for dramatic shadows
        const spot1 = new THREE.SpotLight(0xffaa00, 800);
        spot1.position.set(40, 50, 40);
        spot1.angle = 0.6;
        spot1.penumbra = 1;
        scene.add(spot1);

        const spot2 = new THREE.SpotLight(0x4444ff, 500); // Cold rim light
        spot2.position.set(-40, 20, -40);
        scene.add(spot2);

        // --- POST PROCESSING (BLOOM) ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloom.strength = 1.2; // Intense bloom like the video
        bloom.radius = 0.5;
        bloom.threshold = 0.2;
        composer.addPass(bloom);

        // --- OBJECTS ---
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        const particles = [];
        const photos = [];

        // Materials
        const matGold = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.gold, metalness: 1, roughness: 0.15,
            emissive: 0x443300, emissiveIntensity: 0.2
        });
        const matRed = new THREE.MeshPhysicalMaterial({ 
            color: CONFIG.colors.red, metalness: 0.2, roughness: 0.1, clearcoat: 1.0 
        });
        const matCane = new THREE.MeshStandardMaterial({ map: createCandyTexture(), roughness: 0.3 });
        
        // Geometries
        const geoBox = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const geoSphere = new THREE.SphereGeometry(0.5, 32, 32);
        
        // Generate System
        function initParticles() {
            // 1. Structural Particles
            for(let i=0; i<CONFIG.particleCount; i++) {
                let mesh;
                const r = Math.random();
                
                if (r < 0.05) {
                    // Candy Canes (Rare)
                    const curve = new THREE.CatmullRomCurve3([
                        new THREE.Vector3(0,-1,0), new THREE.Vector3(0,1,0), 
                        new THREE.Vector3(0.5,1.5,0), new THREE.Vector3(1,1.2,0)
                    ]);
                    mesh = new THREE.Mesh(new THREE.TubeGeometry(curve, 16, 0.15, 8, false), matCane);
                    mesh.scale.setScalar(1.5);
                } else if (r < 0.1) {
                    // Placeholder Photos
                    mesh = createPhotoMesh(createDefaultPhoto());
                    mesh.userData.isPhoto = true;
                    photos.push(mesh);
                } else if (r < 0.6) {
                    // Gold Ornaments
                    mesh = new THREE.Mesh(r < 0.35 ? geoBox : geoSphere, matGold);
                } else {
                    // Red/Glass Ornaments
                    mesh = new THREE.Mesh(geoSphere, matRed);
                }

                // Random rotation offset
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                
                mainGroup.add(mesh);
                particles.push(new Particle(mesh, i, CONFIG.particleCount));
            }

            // 2. Star Dust (The "Galaxy" look)
            const dustGeo = new THREE.BufferGeometry();
            const pos = [];
            const sizes = [];
            for(let i=0; i<CONFIG.dustCount; i++) {
                pos.push((Math.random()-0.5)*150, (Math.random()-0.5)*150, (Math.random()-0.5)*150);
                sizes.push(Math.random());
            }
            dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            dustGeo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const dustMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.3,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const starSystem = new THREE.Points(dustGeo, dustMat);
            scene.add(starSystem);
        }

        function createPhotoMesh(tex) {
            const g = new THREE.Group();
            const frame = new THREE.Mesh(new THREE.BoxGeometry(2.2, 2.6, 0.1), matGold);
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2.4), new THREE.MeshBasicMaterial({ map: tex }));
            plane.position.z = 0.06;
            g.add(frame);
            g.add(plane);
            return g;
        }

        initParticles();

        // --- LOGIC: UPLOAD & INPUT ---
        document.getElementById('imageInput').addEventListener('change', (e) => {
            const f = e.target.files[0];
            if(!f) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                new THREE.TextureLoader().load(ev.target.result, (t) => {
                    t.colorSpace = THREE.SRGBColorSpace;
                    const mesh = createPhotoMesh(t);
                    mesh.userData.isPhoto = true;
                    mainGroup.add(mesh);
                    
                    // Replace a random particle with this photo
                    const idx = Math.floor(Math.random() * particles.length);
                    mainGroup.remove(particles[idx].mesh);
                    particles[idx].mesh = mesh;
                    photos.push(mesh);
                    
                    // Flash effect
                    const flash = new THREE.PointLight(0xffffff, 20, 20);
                    flash.position.copy(particles[idx].targetPos);
                    scene.add(flash);
                    setTimeout(() => scene.remove(flash), 150);
                });
            }
            reader.readAsDataURL(f);
        });

        window.addEventListener('keydown', (e) => {
            if(e.key.toLowerCase() === 'h') {
                document.getElementById('ui-layer').classList.toggle('ui-hidden');
            }
        });

        // --- COMPUTER VISION SETUP ---
        let handLandmarker;
        const video = document.getElementById('webcam');

        async function initCV() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
                
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.addEventListener("loadeddata", predict);
            } catch (err) {
                console.warn("CV Init Failed (Check Localhost/HTTPS):", err);
            }
        }

        let lastTime = -1;
        async function predict() {
            if (video.currentTime !== lastTime) {
                lastTime = video.currentTime;
                const result = handLandmarker.detectForVideo(video, performance.now());
                if(result.landmarks && result.landmarks.length > 0) {
                    handleGestures(result.landmarks[0]);
                }
            }
            requestAnimationFrame(predict);
        }

        function handleGestures(lm) {
            // Mapping Hand position to Rotation
            const palm = lm[9];
            STATE.handRotation.y = (palm.x - 0.5) * 3; 
            STATE.handRotation.x = (palm.y - 0.5) * 3;

            // Gestures
            const thumb = lm[4];
            const index = lm[8];
            const wrist = lm[0];
            
            // 1. PINCH -> FOCUS
            if (Math.hypot(thumb.x - index.x, thumb.y - index.y) < 0.05) {
                if(STATE.mode !== 'FOCUS') {
                    STATE.mode = 'FOCUS';
                    STATE.targetPhoto = photos.length ? photos[Math.floor(Math.random()*photos.length)] : null;
                }
            }
            // 2. FIST -> TREE
            else if (Math.hypot(lm[12].x-wrist.x, lm[12].y-wrist.y) < 0.25) {
                STATE.mode = 'TREE';
            }
            // 3. OPEN -> SCATTER
            else if (Math.hypot(lm[12].x-wrist.x, lm[12].y-wrist.y) > 0.45) {
                STATE.mode = 'SCATTER';
            }
        }

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            if(!STATE.isPlaying) return;

            const time = clock.getElapsedTime();

            // Rotate Main Group (Auto + Hand influence)
            const autoRot = STATE.mode === 'TREE' ? time * 0.1 : time * 0.05;
            mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, autoRot + STATE.handRotation.y, 0.05);
            mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, STATE.handRotation.x * 0.5, 0.05);

            // Update particles
            particles.forEach(p => p.update(STATE.mode, time));

            // Move Light with Camera/Time to create dynamic shadows
            coreLight.intensity = 2 + Math.sin(time*3)*0.5;

            composer.render();
        }

        // --- START SEQUENCE ---
        const startBtn = document.getElementById('start-btn');
        const loaderText = document.getElementById('loading-text');

        // Initial loading simulation
        setTimeout(() => {
            loaderText.style.display = 'none';
            document.querySelector('.loader-ring').style.display = 'none';
            startBtn.style.opacity = 1;
            startBtn.style.pointerEvents = 'auto';
        }, 1500);

        startBtn.addEventListener('click', () => {
            document.getElementById('start-screen').style.opacity = 0;
            setTimeout(() => document.getElementById('start-screen').remove(), 1000);
            
            STATE.isPlaying = true;
            
            // --- AUTO PLAY MUSIC LOGIC (FIXED) ---
            // Trigger playback on user interaction (click)
            audio.volume = 0.5;
            audio.play().then(() => {
                console.log("Music started successfully!");
                document.getElementById('music-toggle').style.opacity = '1';
            }).catch(e => {
                console.warn("Autoplay blocked:", e);
                // Just in case, user can still manually click the toggle button later
            });
            
            initCV(); // Start Camera
            animate();
        });

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
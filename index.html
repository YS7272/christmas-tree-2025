<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Magic Christmas - AI Edition</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Times+New+Roman&display=swap" rel="stylesheet">

    <style>
        :root {
            --c-bg: #000000;
            --c-gold: #d4af37;
            --c-gold-light: #fceea7;
            --font-display: 'Cinzel', serif;
        }

        body {
            margin: 0;
            background-color: var(--c-bg);
            overflow: hidden;
            font-family: var(--font-display);
            color: var(--c-gold);
            user-select: none;
            -webkit-tap-highlight-color: transparent; /* ÁßªÈô§ÊâãÊú∫ÁÇπÂáªÈ´ò‰∫Æ */
        }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            transition: opacity 0.5s ease;
            opacity: 0; /* ÂàùÂßãÈöêËóèÔºåÁÇπÂáªÂºÄÂßãÂêéÊòæÁ§∫ */
        }

        /* ÊòæÁ§∫Áä∂ÊÄÅ */
        .ui-visible {
            opacity: 1 !important;
        }

        /* ÈöêËóèÁä∂ÊÄÅ (Áî®‰∫éHÈîÆÊàñÊâãÊú∫ÊåâÈíÆ) */
        .ui-hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Header */
        header {
            position: absolute;
            top: 8%;
            width: 100%;
            text-align: center;
        }

        h1 {
            font-size: clamp(32px, 5vw, 64px);
            margin: 0;
            background: linear-gradient(180deg, #fff, var(--c-gold));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(212, 175, 55, 0.6);
            letter-spacing: 6px;
            text-transform: uppercase;
        }

        .subtitle {
            font-size: 14px;
            color: var(--c-gold-light);
            opacity: 0.7;
            letter-spacing: 3px;
            margin-top: 10px;
        }

        /* Controls */
        .controls-wrapper {
            position: absolute;
            bottom: 12%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            pointer-events: auto;
            flex-direction: column;
            align-items: center;
        }

        .glass-btn {
            position: relative;
            padding: 12px 36px;
            font-family: var(--font-display);
            font-weight: 700;
            color: #fff;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(212, 175, 55, 0.5);
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            text-transform: uppercase;
            letter-spacing: 2px;
            overflow: hidden;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        input[type="file"] { display: none; }

        .hint {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 1px;
            text-shadow: 0 0 5px #000;
        }

        /* Music Toggle (Top Right) */
        #music-toggle {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            padding: 0;
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            z-index: 20;
            background: rgba(255,255,255,0.1);
            border: 1px solid var(--c-gold);
            color: var(--c-gold);
            backdrop-filter: blur(5px);
        }

        /* [NEW] Mobile Hide UI Toggle (Top Right, below music) */
        #ui-toggle-btn {
            position: absolute;
            top: 80px;
            right: 30px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            padding: 0;
            pointer-events: auto;
            display: none; /* ÂàùÂßãÈöêËóèÔºåÂºÄÂßãÂêéÊòæÁ§∫ */
            justify-content: center;
            align-items: center;
            font-size: 18px;
            z-index: 20;
            background: rgba(255,255,255,0.1);
            border: 1px solid var(--c-gold);
            color: var(--c-gold);
            backdrop-filter: blur(5px);
            cursor: pointer;
        }

        /* --- Loader / Start Screen --- */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, #1a0b2e 0%, #000000 100%);
            z-index: 999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease, visibility 1s;
        }

        .loader-ring {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(212, 175, 55, 0.1);
            border-top: 2px solid var(--c-gold);
            border-radius: 50%;
            animation: spin 1.5s cubic-bezier(0.68, -0.55, 0.27, 1.55) infinite;
            margin-bottom: 30px;
        }

        #start-btn {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        /* [NEW] Producer Credit */
        .producer-credit {
            margin-top: 40px;
            font-size: 12px;
            color: var(--c-gold);
            letter-spacing: 2px;
            opacity: 0.8;
            font-family: var(--font-display);
            text-transform: uppercase;
            animation: fadeIn 3s ease;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes fadeIn { 0% { opacity: 0; } 100% { opacity: 0.8; } }

        /* --- Webcam Monitor --- */
        #cv-debug {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 100px;
            opacity: 0; /* Set to 1 to debug */
            pointer-events: none;
            z-index: 100;
            border-radius: 8px;
            transform: scaleX(-1);
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <!-- Êú¨Âú∞Èü≥‰πêÊñá‰ª∂ -->
    <audio id="bgm" loop preload="auto">
        <source src="./music.mp3" type="audio/mpeg">
    </audio>

    <!-- Start / Loader Screen -->
    <div id="start-screen">
        <div class="loader-ring"></div>
        <div id="loading-text" style="color:var(--c-gold); letter-spacing: 3px; font-size: 12px;">LOADING HOLIDAY MAGIC...</div>
        
        <button id="start-btn" class="glass-btn">
            ENTER THE MAGIC
        </button>

        <!-- [NEW] Âà∂‰Ωú‰∫∫ÁΩ≤Âêç -->
        <div class="producer-credit">Âà∂‰Ωú‰∫∫ÔºöSteven Yang 2025.12.13</div>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <header>
            <h1>Merry Christmas</h1>
            <div class="subtitle">AI POWERED INTERACTIVE GREETING</div>
        </header>

        <div class="controls-wrapper">
            <label class="glass-btn">
                <span>üì∑ ADD MEMORIES</span>
                <input type="file" id="imageInput" accept="image/*">
            </label>
            <div class="hint">Tap Eye Icon to Hide Controls</div>
        </div>
    </div>

    <!-- Music Toggle -->
    <button id="music-toggle" class="glass-btn" style="padding:0; width:40px; height:40px;">‚ô´</button>
    
    <!-- [NEW] Mobile Hide UI Button -->
    <button id="ui-toggle-btn" title="Hide/Show UI">üëÅÔ∏è</button>

    <!-- CV Container -->
    <div id="cv-debug">
        <video id="webcam" style="width:100%; border-radius:8px;" autoplay playsinline muted></video>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- CONFIGURATION ---
        const CONFIG = {
            colors: {
                gold: 0xd4af37,
                cream: 0xfceea7,
                red: 0x8a0b0b,
                green: 0x0b3815
            },
            particleCount: 1800, // Reduced slightly for mobile performance safety
            dustCount: 2500
        };

        // --- STATE MANAGEMENT ---
        const STATE = {
            mode: 'TREE', // TREE, SCATTER, FOCUS
            targetPhoto: null,
            handRotation: { x: 0, y: 0 },
            isPlaying: false,
            musicOn: true
        };

        // --- AUDIO SYSTEM ---
        const audio = document.getElementById('bgm');
        audio.volume = 0.6;

        document.getElementById('music-toggle').addEventListener('click', () => {
            const btn = document.getElementById('music-toggle');
            if(audio.paused) {
                audio.play();
                btn.style.opacity = '1';
                btn.innerHTML = "‚ô´";
            } else {
                audio.pause();
                btn.style.opacity = '0.5';
                btn.innerHTML = "üîá";
            }
        });

        // --- [NEW] MOBILE UI TOGGLE ---
        const uiToggleBtn = document.getElementById('ui-toggle-btn');
        const uiLayer = document.getElementById('ui-layer');
        
        uiToggleBtn.addEventListener('click', () => {
            if (uiLayer.classList.contains('ui-visible')) {
                uiLayer.classList.remove('ui-visible');
                uiLayer.classList.add('ui-hidden');
                uiToggleBtn.innerHTML = "üôà"; // Closed eyes
                uiToggleBtn.style.opacity = "0.5";
            } else {
                uiLayer.classList.remove('ui-hidden');
                uiLayer.classList.add('ui-visible');
                uiToggleBtn.innerHTML = "üëÅÔ∏è"; // Open eyes
                uiToggleBtn.style.opacity = "1";
            }
        });

        // Keep 'H' key for desktop
        window.addEventListener('keydown', (e) => {
            if(e.key.toLowerCase() === 'h') {
                uiToggleBtn.click();
            }
        });

        // --- ASSET GENERATION ---
        function createCandyTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#fff'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#cc0000';
            for(let i=-128; i<256; i+=32) {
                ctx.beginPath();
                ctx.moveTo(i, 0); ctx.lineTo(i+16, 0);
                ctx.lineTo(i+16-64, 128); ctx.lineTo(i-64, 128);
                ctx.fill();
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            tex.anisotropy = 16;
            return tex;
        }

        // --- PARTICLE CLASS ---
        class Particle {
            constructor(mesh, index, total) {
                this.mesh = mesh;
                this.index = index;
                this.total = total;
                this.baseScale = mesh.scale.x;
                this.velocity = new THREE.Vector3((Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02);
                this.targetPos = new THREE.Vector3();
                this.targetRot = new THREE.Euler();
                this.targetScale = new THREE.Vector3(1,1,1);
                this.phase = Math.random() * Math.PI * 2;
                this.mesh.position.set((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
            }

            update(mode, time) {
                if (mode === 'TREE') this.calculateTree(time);
                else if (mode === 'SCATTER') this.calculateScatter(time);
                else if (mode === 'FOCUS') this.calculateFocus(time);

                this.mesh.position.lerp(this.targetPos, 0.04);
                
                // Rotation handling
                if (mode === 'FOCUS' && this.mesh === STATE.targetPhoto) {
                    // [NEW] Photo always faces camera in focus mode
                    this.mesh.lookAt(camera.position); 
                } else {
                    const currentQ = new THREE.Quaternion().setFromEuler(this.mesh.rotation);
                    const targetQ = new THREE.Quaternion().setFromEuler(this.targetRot);
                    this.mesh.rotation.setFromQuaternion(currentQ.slerp(targetQ, 0.05));
                }
                
                this.mesh.scale.lerp(this.targetScale, 0.05);
            }

            calculateTree(time) {
                const h = 45;
                const iNorm = this.index / this.total;
                const y = -20 + iNorm * h;
                const radius = 18 * (1 - iNorm); 
                const angle = this.index * 0.8 + time * 0.1;
                const bob = Math.sin(time * 2 + this.phase) * 0.5;
                this.targetPos.set(Math.cos(angle)*radius, y+bob, Math.sin(angle)*radius);
                this.targetRot.set(0, -angle, 0);
                this.targetScale.setScalar(this.baseScale);
            }

            calculateScatter(time) {
                if(!this.scatterOrigin) {
                    const r = 15 + Math.random() * 25;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    this.scatterOrigin = new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                }
                const orbitSpeed = 0.2;
                const x = this.scatterOrigin.x * Math.cos(time * orbitSpeed) - this.scatterOrigin.z * Math.sin(time * orbitSpeed);
                const z = this.scatterOrigin.x * Math.sin(time * orbitSpeed) + this.scatterOrigin.z * Math.cos(time * orbitSpeed);
                this.targetPos.set(x, this.scatterOrigin.y + Math.sin(time + this.index)*2, z);
                this.targetRot.x += 0.01;
                this.targetRot.y += 0.01;
                this.targetScale.setScalar(this.baseScale);
            }

            calculateFocus() {
                if (this.mesh.userData.isPhoto && this.mesh === STATE.targetPhoto) {
                    this.targetPos.set(0, 0, 40); // Move closer to camera
                    this.targetScale.setScalar(4.0); // Make bigger
                } else {
                    this.calculateTree(0);
                    this.targetPos.multiplyScalar(2.5);
                    this.targetPos.z -= 20;
                    this.targetScale.setScalar(0.1);
                }
            }
        }

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015);
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 0, 60);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        scene.add(new THREE.AmbientLight(0xffffff, 0.2));
        const coreLight = new THREE.PointLight(CONFIG.colors.gold, 2, 60);
        scene.add(coreLight);
        const spot1 = new THREE.SpotLight(0xffaa00, 800); spot1.position.set(40, 50, 40); scene.add(spot1);
        const spot2 = new THREE.SpotLight(0x4444ff, 500); spot2.position.set(-40, 20, -40); scene.add(spot2);

        // Post Processing
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloom.strength = 1.2; bloom.radius = 0.5; bloom.threshold = 0.2;
        composer.addPass(bloom);

        // Objects
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);
        const particles = [];
        const photos = [];

        const matGold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1, roughness: 0.15 });
        const matRed = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.red, metalness: 0.2, roughness: 0.1 });
        const matCane = new THREE.MeshStandardMaterial({ map: createCandyTexture(), roughness: 0.3 });
        const geoBox = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const geoSphere = new THREE.SphereGeometry(0.5, 32, 32);

        function initParticles() {
            for(let i=0; i<CONFIG.particleCount; i++) {
                let mesh;
                const r = Math.random();
                if (r < 0.05) {
                    const curve = new THREE.CatmullRomCurve3([new THREE.Vector3(0,-1,0), new THREE.Vector3(0,1,0), new THREE.Vector3(0.5,1.5,0), new THREE.Vector3(1,1.2,0)]);
                    mesh = new THREE.Mesh(new THREE.TubeGeometry(curve, 16, 0.15, 8, false), matCane);
                    mesh.scale.setScalar(1.5);
                } else if (r < 0.6) {
                    mesh = new THREE.Mesh(r < 0.35 ? geoBox : geoSphere, matGold);
                } else {
                    mesh = new THREE.Mesh(geoSphere, matRed);
                }
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                mainGroup.add(mesh);
                particles.push(new Particle(mesh, i, CONFIG.particleCount));
            }
            
            // Dust
            const dustGeo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<CONFIG.dustCount; i++) pos.push((Math.random()-0.5)*150, (Math.random()-0.5)*150, (Math.random()-0.5)*150);
            dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const dustMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.3, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending});
            scene.add(new THREE.Points(dustGeo, dustMat));
        }

        // --- [NEW] PHOTO CREATION (FIXED) ---
        function createPhotoMesh(tex) {
            const g = new THREE.Group();
            
            // Frame
            const frame = new THREE.Mesh(new THREE.BoxGeometry(2.4, 2.8, 0.1), matGold);
            g.add(frame);

            // Photo - Using BasicMaterial so lighting doesn't darken it
            // DoubleSide ensures it's visible even if rotated back
            const picMat = new THREE.MeshBasicMaterial({ 
                map: tex, 
                side: THREE.DoubleSide 
            });
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(2.2, 2.6), picMat);
            plane.position.z = 0.06; // Slightly in front
            g.add(plane);
            
            return g;
        }

        initParticles();

        // --- LOGIC: UPLOAD & INPUT ---
        document.getElementById('imageInput').addEventListener('change', (e) => {
            const f = e.target.files[0];
            if(!f) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                new THREE.TextureLoader().load(ev.target.result, (t) => {
                    t.colorSpace = THREE.SRGBColorSpace;
                    const mesh = createPhotoMesh(t);
                    mesh.userData.isPhoto = true;
                    mainGroup.add(mesh);
                    
                    const idx = Math.floor(Math.random() * particles.length);
                    mainGroup.remove(particles[idx].mesh);
                    particles[idx].mesh = mesh;
                    photos.push(mesh);
                    
                    // Trigger Focus Mode
                    STATE.targetPhoto = mesh;
                    STATE.mode = 'FOCUS';
                    
                    // Reset to Tree after 5 seconds
                    setTimeout(() => { if(STATE.mode === 'FOCUS') STATE.mode = 'TREE'; }, 5000);
                });
            }
            reader.readAsDataURL(f);
        });

        // --- START SEQUENCE ---
        const startBtn = document.getElementById('start-btn');
        const loaderText = document.getElementById('loading-text');

        setTimeout(() => {
            loaderText.style.display = 'none';
            document.querySelector('.loader-ring').style.display = 'none';
            startBtn.style.opacity = 1;
            startBtn.style.pointerEvents = 'auto';
        }, 1500);

        startBtn.addEventListener('click', () => {
            document.getElementById('start-screen').style.opacity = 0;
            setTimeout(() => document.getElementById('start-screen').remove(), 1000);
            
            // Show main UI
            document.getElementById('ui-layer').classList.add('ui-visible');
            document.getElementById('ui-toggle-btn').style.display = 'flex'; // Show toggle btn

            STATE.isPlaying = true;
            audio.play().catch(e => console.log("Audio play failed, user interaction needed first"));
            
            initCV(); 
            animate();
        });

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            if(!STATE.isPlaying) return;

            const time = clock.getElapsedTime();

            mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, (time * 0.1) + STATE.handRotation.y, 0.05);
            mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, STATE.handRotation.x * 0.5, 0.05);

            particles.forEach(p => p.update(STATE.mode, time));
            coreLight.intensity = 2 + Math.sin(time*3)*0.5;

            composer.render();
        }

        // --- COMPUTER VISION ---
        let handLandmarker;
        const video = document.getElementById('webcam');

        async function initCV() {
            try {
                // Mobile constraint check
                const constraints = { video: { facingMode: "user" } };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
                
                video.addEventListener("loadeddata", predict);
            } catch (err) { console.warn("CV Init Failed:", err); }
        }

        let lastTime = -1;
        async function predict() {
            if (video.currentTime !== lastTime) {
                lastTime = video.currentTime;
                const result = handLandmarker.detectForVideo(video, performance.now());
                if(result.landmarks && result.landmarks.length > 0) {
                    const lm = result.landmarks[0];
                    const palm = lm[9];
                    STATE.handRotation.y = (palm.x - 0.5) * 3; 
                    STATE.handRotation.x = (palm.y - 0.5) * 3;

                    const thumb = lm[4], index = lm[8], wrist = lm[0];
                    if (Math.hypot(thumb.x - index.x, thumb.y - index.y) < 0.05) {
                        if(STATE.mode !== 'FOCUS') {
                            STATE.mode = 'FOCUS';
                            STATE.targetPhoto = photos.length ? photos[Math.floor(Math.random()*photos.length)] : null;
                        }
                    } else if (Math.hypot(lm[12].x-wrist.x, lm[12].y-wrist.y) < 0.25) STATE.mode = 'TREE';
                    else if (Math.hypot(lm[12].x-wrist.x, lm[12].y-wrist.y) > 0.45) STATE.mode = 'SCATTER';
                }
            }
            requestAnimationFrame(predict);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>